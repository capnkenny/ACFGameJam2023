using UnityEngine;
using System.Text;
using System.Collections.Generic;
using System;
using System.Linq;

public class NewLevelGenerator : MonoBehaviour
{
    #region Room constants
    
    #endregion Room constants
    
    #region Defaults

    private const int DEFAULT_GRID_SIZE = 8;
    private const int DEFAULT_CARDINAL_WEIGHT = 10;
    private const int DEFAULT_DIAGONAL_WEIGHT = 14;

    private const float DEFAULT_GENERATION_SEED = 2.6;

    #endregion Defaults

    #region Serialized Fields

    [SerializeField]
    private GameObject _roomPrefab;

    [SerializeField]
    private GameObject _debugPrefab;

    [SerializeField]
    private int _levelNumber;

    [SerializeField]
    private float _levelGenerationSeed;

    [SerializeField]
    private int _gridWidth;

    [SerializeField]
    private int _gridHeight;

    [SerializeField]
    private float _yDistanceForPrefab;
    //13.68

    [SerializeField]
    private float _xDistanceForPrefab;
    //35.41
    
    #endregion Serialized Fields

    #region Private members
    
    private int _numberOfRooms;

    private List<List<RoomData>> _grid;

    private Vector2Int _startingRoom;

    private Vector2Int _endRoom;

    private List<RoomData> _validPath;

    #endregion Private members

    void Start()
    {
        //Validation
        if(_gridHeight == 0)
            _gridHeight = DEFAULT_GRID_SIZE;
        if(_gridWidth == 0)
            _gridWidth = DEFAULT_GRID_SIZE;
        if(_levelNumber == 0)
            _levelNumber++;
        if(_levelGenerationSeed == 0.0f || _levelGenerationSeed > 10.0f)
            _levelGenerationSeed = UnityEngine.Random.Range(1.5f, 8.0f);

        //Debug Output
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("Initial Values");
        sb.AppendFormat("Grid Size: {0}, {1}", _gridWidth, _gridHeight).AppendLine();
        sb.AppendFormat("Level: {0}", _levelNumber).AppendLine();
        sb.AppendFormat("Seed: {0}", _levelGenerationSeed).AppendLine();
        Debug.Log(sb.ToString());

        bool foundPath = false;

        for(int i = 0; i < 3; i++)
        {
            //Initialize Grid
            InitializeGrid();
    
            //Determine Neighbors
            foundPath = Search();

            if(foundPath)
                i = 3;
        }

        if(!foundPath)
        {
            throw new ArgumentException("Unable to generate proper grid");
        }

        GenerateLevel();
    }

    private void InitializeGrid()
    {
        _validPath = new List<RoomData>();
        _grid = new List<List<RoomData>>();
        int roomNumber = 1;
        int sX = 0;
        int sY = 0;
        foreach(var list in _grid)
        {
            sX = 0;
            list = new List<RoomData>();
            for(int i = 0; i < _gridWidth; i++)
            {
                list.Add(new RoomData
                    { 
                        X = sX, 
                        Y = sY, 
                        RoomNumber = roomNumber, 
                        Enabled = true, 
                        Spawn = false, 
                        End = false, 
                        Bonus = false,
                        Parent = null
                    }
                );
                roomNumber++;
                sX++;
            }
            sY++;
        }

        //Get starting room
        int x = Random.Range(0, _gridWidth);
        int y = Random.Range(0, _gridHeight);
        _grid[y][x].Spawn = true;
        _grid[y][x].GivenCost = DetermineGivenCost(_grid[y][x]);
        _grid[y][x].HeuristicCost = DetermineHeuristicCost(_grid[y][x], _grid[y][x]);
        _grid[y][x].Parent == null;
        _startingRoom = new Vector2Int(x, y);

        //Get End room
        int eX = Random.Range(0, _gridWidth);
        int eY = Random.Range(0, _gridHeight);
        //Make sure its not the same as the starting room
        while(eX == x && eY == y)
        {
            eX = Random.Range(0, _gridWidth);
            eY = Random.Range(0, _gridHeight);
        }
        _grid[eY][ex].End = true;
        _endRoom = new Vector2Int(eX, eY);

        //Disable a random bunch of rooms
        int toDisable = Random.Range(1, 4);
        for(int i = 0; i < toDisable; i++)
        {
            int dX = Random.Range(0, _gridWidth);
            int dY = Random.Range(0, _gridHeight);

            bool matchesEnd = (dX == eX) && (dY == eY);
            bool matchesSpawn = (dX == x) && (dY == y);
            while(matchesEnd || matchesSpawn)
            {
                dX = Random.Range(0, _gridWidth);
                dY = Random.Range(0, _gridHeight);
                matchesEnd = (dX == eX) && (dY == eY);
                matchesSpawn = (dX == x) && (dY == y);
            }

            _grid[dY][dX].Enabled = false;
        }
    }

    private bool Search()
    {
        //Create an open list to check, and a closed list of rooms
        // we don't need to check anymore.
        var openList = new List<RoomData>();
        var closedList = new List<RoomData>();

        //Add the starting room to the list
        openList.Add(_grid[_startingRoom.y][_startingRoom.x]);

        //Recursion begins
        while(openList.Count > 0 && !openList.Any(r => r.RoomNumber == _grid[_endRoom.y][_endRoom.x].RoomNumber))
        {
            //Get lowest F cost
            var room = openList.OrderBy(r => r.FullCost).First();
            
            //Remove lowest cost and move to closed list
            openList.Remove(room);
            closedList.Add(room);

            //Check da naybuhs
            DetermineNeighbors(ref room, ref closedList);
            
            if(closedList.Any(r => r.RoomNumber == _grid[_endRoom.y][_endRoom.x].RoomNumber))
            {
                return true;
            }
        }

        return false;
    }
    
    private void DetermineNeighbors(ref RoomData room, ref List<RoomData> closed)
    {
        //Check if east neighbor is valid
        if(room.X + 1 < _gridWidth)
        {
            //Check if east neighbor is walkable
            if(_grid[room.Y][room.X + 1].Enabled && !closed.Any(r => r.RoomNumber == _grid[room.Y][room.X + 1].RoomNumber))
            {
                if(!openList.Any(r => r.RoomNumber == _grid[room.Y][room.X + 1].RoomNumber))
                {
                    _grid[room.Y][room.X + 1].Parent = room;
                    _grid[room.Y][room.X + 1].GivenCost = DetermineGivenCost(room, _grid[room.Y][room.X + 1]);
                    _grid[room.Y][room.X + 1].HeuristicCost = DetermineHeuristicCost(_grid[room.Y][room.X + 1], _grid[_endRoom.Y][_endRoom.X + 1]);
                    openList.Add(_grid[room.Y][room.X + 1]);
                }
                else
                {
                    var foundRoom = openList.First(r => r.RoomNumber == _grid[room.Y][room.X + 1].RoomNumber);
                    int newCost = DetermineGivenCost(room) + 10;
                    if(newCost < foundRoom.GivenCost)
                    {
                        foundRoom.Parent = room;
                        foundRoom.GivenCost = newCost;
                    }
                }
                
            }
        }   
        //North neighbor
        if(room.Y + 1 < _gridHeight)
        {
            if(_grid[room.Y + 1][room.X].Enabled && !closed.Any(r => r.RoomNumber == _grid[room.Y + 1][room.X].RoomNumber))
            {
                if(!openList.Any(r => r.RoomNumber == _grid[room.Y + 1][room.X].RoomNumber))
                {
                    _grid[room.Y + 1][room.X].Parent = room;
                    _grid[room.Y + 1][room.X].GivenCost = DetermineGivenCost(room, _grid[room.Y + 1][room.X]);
                    _grid[room.Y + 1][room.X].HeuristicCost = DetermineHeuristicCost(_grid[room.Y + 1][room.X], _grid[_endRoom.Y][_endRoom.X]);
                    openList.Add(_grid[room.Y + 1][room.X]);
                }
                else
                {
                    var foundRoom = openList.First(r => r.RoomNumber == _grid[room.Y + 1][room.X].RoomNumber);
                    int newCost = DetermineGivenCost(room) + 10;
                    if(newCost < foundRoom.GivenCost)
                    {
                        foundRoom.Parent = room;
                        foundRoom.GivenCost = newCost;
                    }
                }
            }
        }
        //West neighbor
        if(room.X - 1 >= 0)
        {
            if(_grid[room.Y][room.X - 1].Enabled && !closed.Any(r => r.RoomNumber == _grid[room.Y][room.X - 1].RoomNumber))
            {
                if(!openList.Any(r => r.RoomNumber == _grid[room.Y][room.X - 1].RoomNumber))
                {
                    _grid[room.Y][room.X - 1].Parent = room;
                    _grid[room.Y][room.X - 1].GivenCost = DetermineGivenCost(room, _grid[room.Y][room.X - 1]);
                    _grid[room.Y][room.X - 1].HeuristicCost = DetermineHeuristicCost(_grid[room.Y][room.X - 1], _grid[_endRoom.Y][_endRoom.X - 1]);
                    openList.Add(_grid[room.Y][room.X - 1]);
                }
                else
                {
                    var foundRoom = openList.First(r => r.RoomNumber == _grid[room.Y][room.X - 1].RoomNumber);
                    int newCost = DetermineGivenCost(room) + 10;
                    if(newCost < foundRoom.GivenCost)
                    {
                        foundRoom.Parent = room;
                        foundRoom.GivenCost = newCost;
                    }
                }
            }
        }
        //South Neighbor   
        if(room.Y - 1 >= 0)
        {
            if(_grid[room.Y - 1][room.X].Enabled && !closed.Any(r => r.RoomNumber == _grid[room.Y - 1][room.X].RoomNumber))
            {
                if(!openList.Any(r => r.RoomNumber == _grid[room.Y - 1][room.X].RoomNumber))
                {
                    _grid[room.Y - 1][room.X].Parent = room;
                    _grid[room.Y - 1][room.X].GivenCost = DetermineGivenCost(room, _grid[room.Y - 1][room.X]);
                    _grid[room.Y - 1][room.X].HeuristicCost = DetermineHeuristicCost(_grid[room.Y - 1][room.X], _grid[_endRoom.Y][_endRoom.X]);
                    openList.Add(_grid[room.Y - 1][room.X]);
                }
                else
                {
                    var foundRoom = openList.First(r => r.RoomNumber == _grid[room.Y - 1][room.X].RoomNumber);
                    int newCost = DetermineGivenCost(room) + 10;
                    if(newCost < foundRoom.GivenCost)
                    {
                        foundRoom.Parent = room;
                        foundRoom.GivenCost = newCost;
                    }
                }
            }
        }
    }

    private int DetermineGivenCost(RoomData target)
    {
        int xDiff = Math.Abs(_startingRoom.x - target.X);
        int yDiff = Math.Abs(_startingRoom.y - target.Y);
        int diff = Math.Abs(xDiff - yDiff);

        if(diff == 0)
            return 0;
        if(xDiff == 0 || yDiff == 0)
            return ((xDiff + yDiff) * DEFAULT_CARDINAL_WEIGHT);
        
        //Diagonal
        if(xDiff == yDiff)
            return xDiff * DEFAULT_DIAGONAL_WEIGHT;
        else if(xDiff > yDiff)
            return (yDiff * DEFAULT_DIAGONAL_WEIGHT) + (diff * DEFAULT_CARDINAL_WEIGHT);
        else
            return (xDiff * DEFAULT_DIAGONAL_WEIGHT) + (diff * DEFAULT_CARDINAL_WEIGHT);
    }

    private int DetermineHeuristicCost(RoomData start, RoomData target)
    {
        //Manhattan-based estimation says to ignore all obstacles, and count
        // both number of vertical spaces plus horizontal spaces to get from
        // start to finish, like if you were counting city blocks (a la Manhattan, NY).
        if(start.RoomNumber == target.RoomNumber)
            return 0;

        int x = Math.Abs(start.X - target.X);
        int y = Math.Abs(start.Y - target.Y);
        
        return (x+y) * DEFAULT_CARDINAL_WEIGHT;
    }

    private List<RoomData> FindPathToEnd()
    {
        List<RoomData> path = new List<RoomData>();
        RoomData currentRoom = _grid[_endRoom.y][_endRoom.x];
        while(currentRoom != null)
        {
            path.Add(currentRoom);
            currentRoom = currentRoom.Parent;
        }
        
        return path;
    }

    private void GenerateLevel()
    {
        var path = FindPathToEnd();

        foreach(var room in path)
        {
            CreateRoomPrefab(room);
        }
    }

    private void CreateRoomPrefab(RoomData data)
    {
        var gameObject = Instantiate(_roomPrefab, new Vector2(data.X * _xDistanceForPrefab, data.Y * _yDistanceForPrefab), Quaternion.identity, transform);
        gameObject.name = $"Room{data.RoomNumber}";
        var comp = gameObject.GetComponent<Room>();
        if(comp == null)
            throw new NullReferenceException("An error occurred when creating the prefab - could not retrieve component!");
        comp.RoomNumber = data.RoomNumber;
        comp.X = data.X;
        comp.Y = data.Y;
        if(data.Spawn)
        {
            var floor = gameObject.transform.Find("Floor");
            var render = floor.GetComponent<SpriteRenderer>();
            render.color = Color.green;
        }
        if(data.End)
        {
            var floor = gameObject.transform.Find("Floor");
            var render = floor.GetComponent<SpriteRenderer>();
            render.color = Color.red;
        }
        if(data.Bonus)
        {
            var floor = gameObject.transform.Find("Floor");
            var render = floor.GetComponent<SpriteRenderer>();
            render.color = Color.yellow;
        }
    }

}